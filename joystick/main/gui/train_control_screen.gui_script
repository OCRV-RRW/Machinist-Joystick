local pipegame_module = require('main.modules.pipegame')
local customstyle = require('main.gui.style')
local crane_hidden = vmath.vector3(2160, 600, 0)
local crane_shown = vmath.vector3(540, 600, 0)
local controller_hidden = vmath.vector3(-2160, 600, 0)
local controller_shown = vmath.vector3(-540, 600, 0)

local contorller_value = {
	[0] = 0.25,
	[1] = 0.5,
	[2] = 0.75,
	[3] = 1,
	[4] = 0
}

local contorller_colors = {
	[0] = vmath.vector4(0, 0, 1, 1),
	[0.25] = vmath.vector4(0, 0, 1, 1),
	[0.5] = vmath.vector4(0, 0, 1, 1),
	[0.75] = vmath.vector4(0, 0, 1, 1),
	[1] = vmath.vector4(0, 0, 1, 1)
}

local contorller_signals = {
	[0] = 4,
	[0.25] = 0,
	[0.5] = 1,
	[0.75] = 2,
	[1] = 3
}


local crane_value = {
	[0] = 1,
	[1] = 0.5,
	[2] = 0
}

local crane_colors = {
	[0] = vmath.vector4(1, 0, 0, 1),
	[0.5] = vmath.vector4(1, 0.6, 0, 1),
	[1] = vmath.vector4(0, 1, 0, 1)
}
local crane_signals = {
	[1] = 0,
	[0.5] = 1,
	[0] = 2
}


local function back_button_click(self)
	for k, v in pairs(self.crane_spots) do gui.animate(v, 'color.w', 0, gui.EASING_LINEAR, 0.2) end
	for k, v in pairs(self.controller_spots) do gui.animate(v, 'color.w', 0, gui.EASING_LINEAR, 0.2) end

	gui.animate(self.crane_root, gui.PROP_POSITION, crane_hidden, gui.EASING_INCIRC, 0.2, .3)
	gui.animate(self.controller_root, gui.PROP_POSITION, controller_hidden, gui.EASING_INCIRC, 0.2, .3, function()
		eventbus.publish('into_game')
	end)
	self.back_button:set_enabled(false)
end

local function repair_button_click(self)
	eventbus.publish('pipe_game_colors_view')
end

local function disconnected(self)
	msg.post(bootstrap_url, 'connection_menu')
	self.clicked = false
	ws.TRAINCONTROL.switch_off()
end

local function set_controller_spot(tbl, value, color_tbl)
	for k, v in pairs(tbl) do
		if math.abs(k - value) < 0.1 then
			gui.set_color(v, color_tbl[k])
			gui.animate(v, gui.PROP_SCALE, vmath.vector3(1.4), gui.EASING_LINEAR, .1)
		else
			gui.set_color(v, vmath.vector4(1))
			gui.animate(v, gui.PROP_SCALE, vmath.vector3(1), gui.EASING_LINEAR, .1)
		end
	end
end

local function setup(self)
	self.back_button = self.druid:new_button(gui.get_node('back_btn'), back_button_click)
	self.repair_button = self.druid:new_button(gui.get_node('repair_btn'), repair_button_click)
	self.back_button:set_style(customstyle)
	self.repair_button:set_style(customstyle)

	self.controller_spots = {
		[0] = gui.get_node('r'),
		[0.25] = gui.get_node('0'),
		[0.5] = gui.get_node('m'),
		[0.75] = gui.get_node('first'),
		[1] = gui.get_node('second')
	}

	self.crane_spots = {
		[1] = gui.get_node('release'),
		[0.5] = gui.get_node('hold'),
		[0] = gui.get_node('rise')
	}

	self.crane_root = gui.get_node('crane')
	self.controller_root = gui.get_node('controller')

	gui.set_position(self.crane_root, crane_hidden)
	gui.set_position(self.controller_root, controller_hidden)

	self.crane = self.druid:new_slider('crane_handler', vmath.vector3(0, 260, 0))
	self.crane:set_input_node('crane_input')
	self.crane:set_steps({ 0, 0.5, 1 })
	self.crane:set(crane_value[_G.crane], true)
	set_controller_spot(self.crane_spots, crane_value[tonumber(_G.crane)], crane_colors)
	self.crane.on_change_value:subscribe(function(self, value)
		set_controller_spot(self.crane_spots, value, crane_colors)
		_G.crane = crane_signals[value]
		eventbus.publish('change_train_controller')
	end)

	self.controller = self.druid:new_slider('controller_handler', vmath.vector3(0, 260, 0))
	self.controller:set_input_node('controller_input')
	self.controller:set_steps({ 0, 0.25, 0.5, 0.75, 1 })
	self.controller:set(contorller_value[_G.controller], true)
	set_controller_spot(self.controller_spots, contorller_value[tonumber(_G.controller)], contorller_colors)
	self.controller.on_change_value:subscribe(function(self, value)
		set_controller_spot(self.controller_spots, value, contorller_colors)
		_G.controller = contorller_signals[value]
		eventbus.publish('change_train_controller')
	end)

	gui.animate(self.crane_root, gui.PROP_POSITION, crane_shown, gui.EASING_OUTCIRC, 0.2, .1)
	gui.animate(self.controller_root, gui.PROP_POSITION, controller_shown, gui.EASING_OUTCIRC, 0.2, .1)

	for k, v in pairs(self.crane_spots) do
		gui.set_alpha(v, 0)
		gui.animate(v, 'color.w', 1, gui.EASING_LINEAR, 0.1, 0.5)
	end
	for k, v in pairs(self.controller_spots) do
		gui.set_alpha(v, 0)
		gui.animate(v, 'color.w', 1, gui.EASING_LINEAR, 0.1, 0.5)
	end
end

local function show_repair_button(self)
	pprint("show")
	gui.animate(gui.get_node('repair_btn'), gui.PROP_POSITION, vmath.vector3(0, 822, 0), gui.EASING_OUTELASTIC, 0.2)
end

local function hide_repair_button(self)
	gui.animate(gui.get_node('repair_btn'), gui.PROP_POSITION, vmath.vector3(0, 1200, 0), gui.EASING_OUTELASTIC, 0.2)
end

local function init_events(self)
	self.on_disconnected = function() disconnected(self) end
	self.on_error = function() disconnected(self) end
	self.on_start_pipe_game = function() show_repair_button(self) end
	self.on_exit_pipe_game = function() hide_repair_button(self) end
	eventbus.subscribe('disconnected', self.on_disconnected)
	eventbus.subscribe('error', self.on_error)
	eventbus.subscribe('start_pipe_game', self.on_start_pipe_game)
	eventbus.subscribe('exit_pipe_game', self.on_exit_pipe_game)
end

local function drop_events(self)
	eventbus.unsubscribe('disconnected', self.on_disconnected)
	eventbus.unsubscribe('error', self.on_error)
	eventbus.unsubscribe('start_pipe_game', self.on_start_pipe_game)
	eventbus.unsubscribe('exit_pipe_game', self.on_exit_pipe_game)
	self.on_disconnected = nil
	self.on_error = nil
	self.on_start_pipe_game = nil
	self.on_exit_pipe_game = nil
end


function init(self)
	self.druid = druid.new(self)
	setup(self)
	init_events(self)
	ws.TRAINCONTROL.switch_on()
	if pipegame_module.STARTED then
		eventbus.publish('start_pipe_game')
	end
end

function final(self)
	drop_events(self)
	self.druid:final()
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)
end
