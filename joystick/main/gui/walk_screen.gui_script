local customstyle    = require('main.gui.style')
local buttons_hidden = vmath.vector3(0, -1920, 0)
local buttons_shown  = vmath.vector3(0, 0, 0)
local pipe_module    = require('main.modules.pipegame')

local function disconnected(self)
	msg.post(msg.url('walk', '/ui', 'walk_screen'), 'go_to_connection_menu')
	self.clicked = false
end

local function back_button_click(self)
	self.back_button:set_enabled(false)
	if ws.CONNECTION == nil then
		disconnected(self)
	else
		eventbus.publish('disconnecting')
	end
end

local function show_text_box(self)
	gui.animate(gui.get_node('text_box'), gui.PROP_POSITION, vmath.vector3(540, 1300, 0), gui.EASING_OUTELASTIC, 0.2)
end

local function hide_text_box(self)
	gui.animate(gui.get_node('text_box'), gui.PROP_POSITION, vmath.vector3(540, 2200, 0), gui.EASING_LINEAR, 0.2)
end

local function setup(self)
	self.back_button = self.druid:new_button(gui.get_node('back_btn'), back_button_click)

	self.back_button:set_style(customstyle)
	self.right = self.druid:new_button(gui.get_node('right'))
	self.left = self.druid:new_button(gui.get_node('left'))
	self.interaction = self.druid:new_button(gui.get_node('interaction'))

	self.right.on_pressed:subscribe(function(self, args, btn)
		eventbus.publish('move_interact',
			{ key = ws.WALK.RIGHT, phase = ws.WALK.PHASE.DOWN })
	end)
	self.right.on_click:subscribe(function(self, args, btn)
		eventbus.publish('move_interact', { key = ws.WALK.RIGHT, phase = ws.WALK.PHASE.UP })
		eventbus.publish('move_interact', { key = ws.WALK.RIGHT, phase = ws.WALK.PHASE.CLICK })
	end)
	self.left.on_pressed:subscribe(function(self, args, btn)
		eventbus.publish('move_interact',
			{ key = ws.WALK.LEFT, phase = ws.WALK.PHASE.DOWN })
	end)
	self.left.on_click:subscribe(function(self, args, btn)
		eventbus.publish('move_interact', { key = ws.WALK.LEFT, phase = ws.WALK.PHASE.UP })
		eventbus.publish('move_interact', { key = ws.WALK.LEFT, phase = ws.WALK.PHASE.CLICK })
	end)
	self.interaction.on_pressed:subscribe(function(self, args, btn)
		eventbus.publish('move_interact',
			{ key = ws.WALK.INTERACTION, phase = ws.WALK.PHASE.DOWN })
	end)
	self.interaction.on_click:subscribe(function(self, args, btn)
		eventbus.publish('move_interact', { key = ws.WALK.INTERACTION, phase = ws.WALK.PHASE.UP })
		eventbus.publish('move_interact', { key = ws.WALK.INTERACTION, phase = ws.WALK.PHASE.CLICK })
	end)
	self.buttons = gui.get_node('buttons')
	gui.set_position(self.buttons, buttons_hidden)
	gui.animate(self.buttons, gui.PROP_POSITION, buttons_shown, gui.EASING_OUTCIRC, 0.2, 0.1)
end

local function init_events(self)
	self.on_disconnected = function() disconnected(self) end
	self.on_error = function() disconnected(self) end
	self.on_start_pipe_game = function() msg.post(msg.url('walk', '/ui', 'walk_screen'), "show_text_box") end
	self.on_exit_pipe_game = function() msg.post(msg.url('walk', '/ui', 'walk_screen'), "hide_text_box") end
	eventbus.subscribe('on_start_pipe_game', self.on_start_pipe_game)
	eventbus.subscribe('on_exit_pipe_game', self.on_exit_pipe_game)
	eventbus.subscribe('disconnected', self.on_disconnected)
	eventbus.subscribe('error', self.on_error)
end

local function drop_events(self)
	eventbus.publish('move_interact', {})
	eventbus.unsubscribe('on_start_pipe_game', self.on_start_pipe_game)
	eventbus.unsubscribe('on_exit_pipe_game', self.on_exit_pipe_game)
	eventbus.unsubscribe('disconnected', self.on_disconnected)
	eventbus.unsubscribe('error', self.on_error)
	self.on_start_pipe_game = nil
	self.on_exit_pipe_game = nil
	self.on_disconnected = nil
	self.on_error = nil
end


function init(self)
	self.druid = druid.new(self)
	setup(self)
	init_events(self)
	if pipe_module.STARTED then
		if _G.role == ws.ROLE_CHOOSER.ROLE.TCHM then
			msg.post(msg.url('walk', '/ui', 'walk_screen'), "show_text_box")
		end
	end
end

function final(self)
	drop_events(self)
	self.druid:final()
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
	if message_id == hash('go_to_connection_menu') then
		gui.animate(self.buttons, gui.PROP_POSITION, buttons_hidden, gui.EASING_INCIRC, 0.2, 0, function()
			msg.post(bootstrap_url, 'connection_menu')
		end)
	end
	if message_id == hash('show_text_box') then
		show_text_box(self)
	end
	if message_id == hash('hide_text_box') then
		hide_text_box(self)
	end
end

function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)
end
