local customstyle = require('main.gui.style')
require('main.pipe.pipe_colors')

local function get_level_colors(number)
	local levels_json = sys.load_resource("/resources/json/levels.json")
	local table = json.decode(tostring(levels_json))
	return table["levels"][tostring(number)]["colors"]
end

local function draw_cleats(self, colors_table)
	for k,v in pairs(colors_table) do
		pprint(k)
		pprint(v)
	end
	local draw_cleat = function (index, color)
		local cleat = gui.get_node('cleat_'..tostring(index))
		gui.set_texture(cleat, 'cleat')
		gui.play_flipbook(cleat, 'cleat_'..color)
	end 

	local idx = 0
	for key, value in pairs(colors_table) do
		idx = idx + 1
		draw_cleat(idx,
			string.lower(get_state(key)))
		idx = idx + 1
		draw_cleat(idx,
			string.lower(get_state(value)))
	end
end

local function return_size(self, node)
	gui.animate(node, "scale", vmath.vector3(1, 1, 0), gui.EASING_LINEAR, 0.1)
end

local function start_click_animation(self, node)
	gui.animate(node, "scale", vmath.vector3(1.2, 1.2, 0), gui.EASING_LINEAR, 0.1, 0, return_size)
end

local function repair_button_clicked(self)
	start_click_animation(self, gui.get_node('repair_btn'))
	eventbus.publish('train_control')
end

local function disconnected(self) 
	msg.post(bootstrap_url, 'connection_menu')
end

function init(self)
	self.druid = druid.new(self)
	self.repair_btn = self.druid:new_button(
		gui.get_node('repair_btn'),
		repair_button_clicked)
	self.repair_btn:set_style(customstyle)
	
	self.on_send_pipe_game_data = function(number)
		print("fdfdf")
		local table = get_level_colors(number)
		local colors_table = Convert_colors_table(table)
		draw_cleats(self, colors_table)
	end

	self.on_exit_pipe_game = function()
		eventbus.publish('train_control')
	end

	self.on_disconnected = function() disconnected(self) end
	self.on_error = function() disconnected(self) end


	eventbus.subscribe('send_pipe_game_data', self.on_send_pipe_game_data)
	eventbus.subscribe('on_exit_pipe_game', self.on_exit_pipe_game)
	eventbus.subscribe('disconnected', self.on_disconnected)
	eventbus.subscribe('error', self.on_error)
	eventbus.publish('get_pipe_game_data')
	gui.animate(gui.get_node('text_box'), gui.PROP_POSITION, vmath.vector3(0, 393, 0), gui.EASING_OUTELASTIC, 0.5)
end

function final(self)
	eventbus.unsubscribe('disconnected', self.on_disconnected)
	eventbus.unsubscribe('error', self.on_error)
	eventbus.unsubscribe('send_pipe_game_data', self.on_send_pipe_game_data)
	eventbus.unsubscribe('on_exit_pipe_game', self.on_exit_pipe_game)
	self.on_send_colors_table = nil
	self.on_exit_pipe_game = nil
	self.druid:final()
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)
end

function on_reload(self)
	self.druid:on_reload()
end
