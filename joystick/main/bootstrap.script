eventbus = require('main/modules/eventbus')
ws = require('main.modules.websocket')
druid = require("druid.druid")
local slider = require("druid.extended.slider")
bootstrap_url = msg.url('main', '/root', 'script')
spot_in_line = 1

local function unload(self)
	if self.loaded_proxies == nil then return false end
	for i, v in ipairs(self.loaded_proxies) do
		msg.post(v, 'disable')
		msg.post(v, 'final')
		msg.post(v, 'unload')
		table.remove(self.loaded_proxies, i)
		pprint("Dropped: " .. v)
	end
	return true
end

local function load(self, proxy)
	unload(self)
	local url = msg.url('main', '/root', proxy)
	pprint('load ' .. url)
	msg.post(url, 'load')
end

local function on_loaded(self, sender)
	pprint('Loaded: ' .. sender)
	msg.post(sender, "init")
	msg.post(sender, "enable")
	msg.post(sender, "acquire_input_focus")
	if self.first_load then
		self.first_load = false
		return
	end
	if self.loaded_proxies == nil then self.loaded_proxies = {} end
	table.insert(self.loaded_proxies, sender)
end

local function on_unloaded(self, sender)
end

local function init_events(self)
	self.choose_role_screen   = function()
		msg.post(bootstrap_url, 'choose_role_screen')
	end

	self.queue_screen         = function(data)
		msg.post(bootstrap_url, 'queue_screen', data)
	end

	self.walk_screen          = function(data)
		pprint('post: walk_screen')
		msg.post(bootstrap_url, 'walk_screen', data)
	end

	self.train_control_screen = function(data)
		msg.post(bootstrap_url, 'train_control_screen', data)
	end

	self.mini_game_screen     = function(data)
		msg.post(bootstrap_url, 'mini_game_screen', data)
	end

	self.feedback             = function(data)
		msg.post(bootstrap_url, 'feedback_screen', data)
	end

	eventbus.subscribe('choose_role', self.choose_role_screen)
	eventbus.subscribe('into_queue', self.queue_screen)
	eventbus.subscribe('into_game', self.walk_screen)
	eventbus.subscribe('train_control', self.train_control_screen)
	eventbus.subscribe('mini_game', self.mini_game_screen)
	eventbus.subscribe('feedback', self.feedback)
end

local function drop_events(self)
	eventbus.unsubscribe('feedback', self.feedback)
	eventbus.unsubscribe('train_control', self.train_control_screen)
	eventbus.unsubscribe('into_game', self.walk_screen)
	eventbus.unsubscribe('into_queue', self.queue_screen)
	eventbus.unsubscribe('choose_role', self.choose_role_screen)
	eventbus.unsubscribe('mini_game', self.mini_game_screen)
	self.choose_role_screen = nil
	self.queue_screen = nil
end

function init(self)
	ws.init()
	druid.register("slider", slider)
	self.first_load = true
	load(self, 'connectionmenuproxy')
	init_events(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash('proxy_loaded') then
		on_loaded(self, sender)
	elseif message_id == hash('proxy_unloaded') then
		on_unloaded(self, sender)
	elseif message_id == hash('choose_role_screen') then
		load(self, 'chooseroleproxy')
	elseif message_id == hash('queue_screen') then
		load(self, 'queueproxy')
	elseif message_id == hash('walk_screen') then
		load(self, 'walkproxy')
	elseif message_id == hash('train_control_screen') then
		load(self, 'traincontrolproxy')
	elseif message_id == hash('mini_game_screen') then
		load(self, 'minigameproxy')
	elseif message_id == hash('feedback_screen') then
		load(self, 'feedbackproxy')
	elseif message_id == hash('connection_menu') then
		unload(self)
	end
end

function on_input(self, action_id, action)
	if action_id == hash('controller') and action.released then
		eventbus.publish('feedback')
	end
end

function final(self)
	ws.dispose()
	drop_events(self)
	unload(self)
end
