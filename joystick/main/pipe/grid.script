local colors_module = require("main.pipe.pipe_colors")
local cells_path = require("main.pipe.cells_path")
local colors_table = {}
local level_settings = {}

local function get_level_settings(number)
	local levels_json = sys.load_resource("/resources/json/levels.json")
	local table = json.decode(tostring(levels_json))
	return table["levels"][tostring(number)]["level"]
end

local function get_level_colors(number)
	local levels_json = sys.load_resource("/resources/json/levels.json")
	local table = json.decode(tostring(levels_json))
	pprint("grid")
	pprint(tostring(number))
	return table["levels"][tostring(number)]["colors"]
end

local function clear_path(self, path)
	if path then
		for _, c in pairs(path) do
			msg.post(c, "try_delete_pipe")
		end
		cells_path.clear_path(path)
	else
		for _, c in pairs(self.current_path) do
			msg.post(c, "try_delete_pipe")
		end
		cells_path.clear_path(self.current_path)
	end
end

local function is_valid(self, message, sender)
	return message.is_ended and
		self.current_path[1] ~= sender and
		math.abs(self.current_cell_coords.x - message.coords.x) + math.abs(self.current_cell_coords.y - message.coords.y) <= 1
end

local function getn(table)
	local count = 0
	for _, val in pairs(table) do
		count = count + 1
	end
	return count
end

local function send_message_check_busy(self)
	local count = 0
	for _, value in pairs(self.cells) do
		count = count + 1
		local cell_url = msg.url(nil, value, "cell")
		msg.post(cell_url, "check_busy", {last = count == getn(self.cells)} )
	end
end

local function get_pair_color(value)
	for k, v in pairs(colors_table) do
		if k == value then
			return colors_table[k]
		elseif v == value then
			return k
		end
	end
	return nil
end

local function create_grid(self)
	if #self.cells > 0 then return end
	self.count_cells = 5 * 5
	local idx_cell = 0
	for i = 0, 5 - 1 do
		for j = 0, 5 - 1 do
			idx_cell = idx_cell + 1
			local cell = factory.create("#cell_factory",
				vmath.vector3(i * 140 + 260, j * 140 + 0, 0),
				nil,
				{
					is_ended = level_settings[idx_cell]["isEndPoint"],
					color = level_settings[idx_cell]["endPointColor"],
					coords = vmath.vector3(i, j, 0)
				})
			self.cells[i.." "..j] = cell
			msg.post(cell, "add_cleat")
		end
	end
end

local function reset(self)
	while #cells_pathes ~= 0 do
		clear_path(self, cells_pathes[1])
	end
end

local function exit(self)
	reset(self)
	print("exit")
    eventbus.publish("finish_mini_game")
end

local function on_win(self)
	exit(self)
	eventbus.publish('repair_fuse')
end

local function check_path_state(self, path)
	local first_cell_color = go.get(path[1], "color")
	local last_cell_color = go.get(path[#path], "color")
	if first_cell_color == get_pair_color(last_cell_color) then
		return true
	end

	return false
end

local function check_game_state(self)
	local all_pathes_is_valid = true
	for _, value in ipairs(cells_pathes) do
		if check_path_state(self, value) == false then
			all_pathes_is_valid = false
		end
	end

	if self.count_busy_cells == getn(self.cells) and all_pathes_is_valid then
		on_win(self)
	end
end

local function on_send_pipe_game_data(number)
	pprint("set_table")
	level_settings = get_level_settings(number)
	local table = get_level_colors(number)
	colors_table = Convert_colors_table(table)
	msg.post("#", "create_grid")
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	self.count_cells = 0
	self.cells = {}
	self.count_busy_cells = 0
	self.current_color = colors_module.NONE
	self.on_started = false
	self.current_cell_coords = vmath.vector3(-1, -1, -1)
	self.current_cell = nil
	self.prev_cell = nil
	self.path_cleared = false
	self.prev_cell_coords = vmath.vector3(-1, -1, -1)
	self.current_path = nil
	self.last_touch_pos = nil
	eventbus.subscribe('send_pipe_game_data', on_send_pipe_game_data)
	eventbus.publish('get_pipe_game_data')
	pprint(#cells_pathes)
end

function final(self)
	msg.post(".", "release_input_focus")
	self.count_cells = 0
	self.cells = {}
	self.count_busy_cells = 0
	self.current_color = colors_module.NONE
	self.on_started = false
	self.current_cell_coords = vmath.vector3(-1, -1, -1)
	self.current_cell = nil
	self.prev_cell = nil
	self.path_cleared = false
	self.prev_cell_coords = vmath.vector3(-1, -1, -1)
	self.current_path = nil
	self.last_touch_pos = nil
	reset(self)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		for _, val in pairs(self.cells) do
			local cell_url = msg.url(nil, val, "cell")
			msg.post(cell_url, "on_start", { touch_pos = vmath.vector3(action.x, action.y, 0) })
		end
	elseif action_id == hash("touch") and action.released then
		if self.on_started then
			for _, val in pairs(self.cells) do
				local cell_url = msg.url(nil, val, "cell")
				msg.post(cell_url, "on_release", { touch_pos = vmath.vector3(action.x, action.y, 0) })
			end
			if is_valid(self, 
				{
					is_ended = go.get(self.current_cell, 'is_ended'), 
					coords = go.get(self.current_cell, 'coords')
				}, 
				self.current_cell) then
				send_message_check_busy(self)
			else
				if self.path_cleared == false then
					clear_path(self)
				end
			end
			self.on_started = false
		end
	elseif action_id == hash("touch") then
		if self.on_started then
			for _, val in pairs(self.cells) do
				local cell_url = msg.url(nil, val, "cell")
				msg.post(cell_url, "on_pick_cell", { touch_pos = vmath.vector3(action.x, action.y, 0), vector = {x = 1, y = 2} })
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	local path = nil

	if message_id == hash("create_grid") then
		create_grid(self)
	end

	if message_id == hash("ok_on_start") then
		if message.busy then
			path = get_path_by_cell(sender)
			clear_path(self, path)
			msg.post(sender, "on_release", { touch_pos = message.touch_pos })
			self.on_started = false
			self.path_cleared = true
		elseif not message.busy then
			self.path_cleared = false
			self.on_started = true
			self.current_cell_coords = message.coords
			self.current_cell = sender
			self.current_color = message.color;
			self.current_path = {}
			cells_pathes.add_path(self.current_path)
			msg.post(self.current_cell, "try_create_pipe", { color = message.color, vector = vmath.vector3(0, 0, 0)})
		-- else
		-- 	self.on_started = false
		end
	elseif message_id == hash("ok_on_pick") then
		if math.abs(self.current_cell_coords.x - message.coords.x) + math.abs(self.current_cell_coords.y - message.coords.y) > 1 then
			msg.post(sender, "on_release", { touch_pos = message.touch_pos })
			self.on_started = false
		elseif message.busy == true then
			msg.post(sender, "on_release", { touch_pos = message.touch_pos })
			self.on_started = false
			clear_path(self)
		else
			self.prev_cell_coords = self.current_cell_coords
			self.current_cell_coords = message.coords
			self.prev_cell = self.current_cell
			self.current_cell = sender
			msg.post(self.prev_cell, "update_pipe", { vector = vmath.vector3(self.current_cell_coords.x - self.prev_cell_coords.x,
			self.current_cell_coords.y - self.prev_cell_coords.y, 0)})
			msg.post(sender, "try_create_pipe", { color = self.current_color,
				vector = vmath.vector3(self.current_cell_coords.x - self.prev_cell_coords.x,
				self.current_cell_coords.y - self.prev_cell_coords.y, 0)})
			if message.is_ended then
				msg.post(sender, "on_release", { touch_pos = message.touch_pos })
				self.on_started = false
			end
		end
	elseif message_id == hash("ok_on_release") then
		if is_valid(self, message, sender) then
			send_message_check_busy(self)
		else
			if self.path_cleared == false then
				clear_path(self)
			end
		end
		self.current_cell_coords = vmath.vector3(-1, -1, -1)
		self.prev_cell_coords = vmath.vector3(-1, -1, -1)
		self.current_color = colors_module.NONE
	end

	if message_id == hash("add_cell_to_path") then
		cells_path.try_add_cell(sender)
	end

	if message_id == hash("answer_is_busy") then
		if message.busy then
			self.count_busy_cells = self.count_busy_cells + 1
		end

		if message.last then
			check_game_state(self)
			self.count_busy_cells = 0
		end
	end

	if message_id == hash("reset_btn_click") then
		reset(self)
	end

	if message_id == hash("exit_btn_click") then
		exit(self)
	end
end

function final(self)
	eventbus.unsubscribe('send_pipe_game_data', on_send_pipe_game_data)
end